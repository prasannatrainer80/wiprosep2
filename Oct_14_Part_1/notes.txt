Unit Testing using Spring Reactive Programming

API Testing using Reactive Programming

JWT Authentication 

In Spring Boot, webflux reactive programming allows you to support asynchronous, non-blocking
and event-driven applciations when it comes to testing in the spring webflux, 

we have various ways to implement testing as

1) Unit Testing : It can involve testing individual components of the application. In Spring WebFlux, this might include testing individual handlers, controllers and services using mocking framework. 

2) Integration Testing : It can involve testing for the interactions between the diff components of the application. This might include, testing individual handlers, controllers, and services using mocking 

3) WebTestClient : It is the testing utility to provide to test http requests against the application and verify the responses. We can use it to test both functional and reative endpoints. 

4) MockServer : This is the library that can allow the mock HTTP servers for testing purposes it can be used to mock external dependencies or the services that the application interacts with over http. 

5) SpringBootTest : This is an annotation that can be provided by default with spring boot allows the entire application context and perform the end to end tests on the application.

Spring Boot Testing have various annotations : 
__________________________________________________

1) @RunWith : It can be used at the class level to specify the spring runner and which is responsible for the executing the tests within the spring context and it can enable the integration of the spring TestCotext Framework.

In Reactive Web Programming, we have 6 methods, to handle error. 


-> onErrorReturn : Return fall back value for the entire stream. Eg if there's a flux of 10 elements, and error happens at element 3, then rest 4,5,6 wont be executed. 

-> onErrorResume : Returns fall back value in terms of Mono/Flux. 

-> onErrorContinue : Consumes error data, and does not split it over.  It considers the consume for the error elements, and leave the downstream chain as it 
for good elements. Above example if we have flux of 10 elements
and error happens at element 3, then all the elements except 3 will be executed normally 

-> doOnError : Consumes error and spills it over. Stops execution for further elements in stream.

-> onErrorMap : Casts one error to another error. 